# train_manual.py
import os
import torch
import cv2
import numpy as np
import segmentation_models_pytorch as smp
from torch.utils.data import Dataset, DataLoader

# --- 1. CONFIGURAÇÃO DO TREINO ---
# Diretório onde as pastas 'train_images' e 'train_masks' estão
DATA_DIR = './data/'

# As classes DEVEM estar na mesma ordem da sua interface do Label Studio
# O 'Background' é adicionado como classe 0
CLASSES = ['Background', 'River', 'Vegetation', 'Soil Anomaly', 'Mountain/Hill', 'Rock/Stone', 'Road']
N_CLASSES = len(CLASSES)

# Parâmetros de Treino
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
EPOCHS = 5  # <<< ALTERADO AQUI
LEARNING_RATE = 0.001
BATCH_SIZE = 4  # Reduza para 2 se tiver problemas de memória
TARGET_SIZE = (512, 512)


# --- 2. CLASSE PARA CARREGAR OS DADOS ANOTADOS MANUALMENTE ---
class LabeledDataset(Dataset):
    def __init__(self, images_dir, masks_dir):
        self.image_ids = [f for f in os.listdir(images_dir) if f.endswith(('.jpg', '.png'))]
        self.images_dir = images_dir
        self.masks_dir = masks_dir
        print(f"Encontradas {len(self.image_ids)} imagens e máscaras para treino.")

    def __len__(self):
        return len(self.image_ids)

    def __getitem__(self, idx):
        img_name = self.image_ids[idx]
        img_path = os.path.join(self.images_dir, img_name)

        mask_name = os.path.splitext(img_name)[0] + '.png'
        mask_path = os.path.join(self.masks_dir, mask_name)

        # Carrega a imagem
        image = cv2.imread(img_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, TARGET_SIZE, interpolation=cv2.INTER_AREA)
        image_tensor = torch.from_numpy(image / 255.0).permute(2, 0, 1).float()

        # Carrega a máscara
        mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
        mask = cv2.resize(mask, TARGET_SIZE, interpolation=cv2.INTER_NEAREST)
        mask_tensor = torch.from_numpy(mask).long()

        return image_tensor, mask_tensor


# --- 3. LÓGICA DE TREINO ---
if __name__ == '__main__':
    print(f"A usar o dispositivo: {DEVICE}")
    print("A iniciar o treino com dados ANOTADOS MANUALMENTE...")

    train_dataset = LabeledDataset(
        images_dir=os.path.join(DATA_DIR, 'train_images'),
        masks_dir=os.path.join(DATA_DIR, 'train_masks')
    )

    if len(train_dataset) == 0:
        print("ERRO: Nenhuma imagem/máscara encontrada. Verifique as pastas em './data/'")
    else:
        train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
        model = smp.Unet('resnet34', encoder_weights='imagenet', classes=N_CLASSES, in_channels=3)
        model.to(DEVICE)
        loss_fn = smp.losses.DiceLoss(mode='multiclass', from_logits=True)
        optimizer = torch.optim.Adam(model.parameters(), lr=LEARNING_RATE)

        for epoch in range(EPOCHS):
            model.train()
            running_loss = 0.0
            for images, masks in train_loader:
                images, masks = images.to(DEVICE), masks.to(DEVICE)
                optimizer.zero_grad()
                outputs = model(images)
                loss = loss_fn(outputs, masks)
                loss.backward()
                optimizer.step()
                running_loss += loss.item()
            epoch_loss = running_loss / len(train_loader)
            print(f"Epoch {epoch + 1}/{EPOCHS}, Loss: {epoch_loss:.4f}")

        model_path = 'modelo_preciso.pth'
        torch.save(model.state_dict(), model_path)
        print(f"\nTreino concluído! Modelo de alta precisão salvo como '{model_path}'")
        print("\nPara usar este modelo, abra o script 'predict.py' e altere a variável 'MODEL_PATH'.")
